use anyhow::Result;
use serde_json;
use serde::{Serialize, Deserialize};

use crate::transcribe::TranscriptionResult;

/// Word-level timestamp information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WordTimestamp {
    /// The word content
    pub word: String,
    /// Start time in seconds
    pub start_time: f64,
    /// End time in seconds  
    pub end_time: f64,
    /// Confidence score (0.0 to 1.0)
    pub confidence: Option<f64>,
    /// Speaker ID (if available)
    pub speaker_id: Option<String>,
}

/// Enhanced JSON output with word-level timestamps
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnhancedJsonOutput {
    /// Basic transcription result
    #[serde(flatten)]
    pub result: TranscriptionResult,
    /// Word-level timestamps (if available)
    pub words: Option<Vec<WordTimestamp>>,
}

/// Format transcription as plain text
pub fn format_as_text(result: &TranscriptionResult, include_timestamps: bool, detailed_timestamps: bool) -> String {
    if result.segments.is_empty() {
        return result.transcript.clone();
    }
    
    let mut output = String::new();
    
    // Add header with metadata
    output.push_str(&format!("# Transcription of: {}\n", 
        result.audio_info.title.as_deref().unwrap_or("Unknown")));
    output.push_str(&format!("# Duration: {:.1}s\n", 
        result.metadata.audio_duration.unwrap_or(0.0)));
    output.push_str(&format!("# Language: {}\n", result.metadata.language));
    if let Some(confidence) = result.metadata.confidence {
        output.push_str(&format!("# Confidence: {:.1}%\n", confidence * 100.0));
    }
    output.push_str("# Generated by RustScribe\n\n");
    
    // Add transcript with or without timestamps
    for segment in &result.segments {
        if include_timestamps {
            let timestamp = if detailed_timestamps {
                format_detailed_timestamp(segment.start_time)
            } else {
                format_timestamp(segment.start_time)
            };
            
            if let Some(speaker) = &segment.speaker_id {
                output.push_str(&format!("[{}] Speaker {}: {}\n", timestamp, speaker, segment.text));
            } else {
                output.push_str(&format!("[{}] {}\n", timestamp, segment.text));
            }
        } else {
            // Just text without timestamps
            if let Some(speaker) = &segment.speaker_id {
                output.push_str(&format!("Speaker {}: {}\n", speaker, segment.text));
            } else {
                output.push_str(&format!("{}\n", segment.text));
            }
        }
    }
    
    output
}

/// Format transcription as JSON
pub fn format_as_json(result: &TranscriptionResult) -> Result<String> {
    let enhanced = EnhancedJsonOutput {
        result: result.clone(),
        words: result.words.clone(),
    };
    
    let json = serde_json::to_string_pretty(&enhanced)?;
    Ok(json)
}

/// Format transcription as SRT subtitles
pub fn format_as_srt(result: &TranscriptionResult, detailed_timestamps: bool) -> String {
    let mut output = String::new();
    
    for (i, segment) in result.segments.iter().enumerate() {
        output.push_str(&format!("{}\n", i + 1));
        output.push_str(&format!("{} --> {}\n", 
            format_srt_timestamp(segment.start_time),
            format_srt_timestamp(segment.end_time)
        ));
        
        let text = if let Some(speaker) = &segment.speaker_id {
            format!("<i>Speaker {}:</i> {}", speaker, segment.text)
        } else {
            segment.text.clone()
        };
        
        output.push_str(&format!("{}\n\n", text));
    }
    
    output
}

/// Format transcription as WebVTT
pub fn format_as_vtt(result: &TranscriptionResult, detailed_timestamps: bool) -> String {
    let mut output = String::from("WEBVTT\n\n");
    
    // Add metadata
    output.push_str(&format!("NOTE\nTranscribed by RustScribe\n"));
    output.push_str(&format!("Source: {}\n", 
        result.audio_info.title.as_deref().unwrap_or("Unknown")));
    output.push_str(&format!("Language: {}\n\n", result.metadata.language));
    
    for segment in &result.segments {
        output.push_str(&format!("{} --> {}\n", 
            format_vtt_timestamp(segment.start_time),
            format_vtt_timestamp(segment.end_time)
        ));
        
        let text = if let Some(speaker) = &segment.speaker_id {
            format!("<v Speaker {}>{}",  speaker, segment.text)
        } else {
            segment.text.clone()
        };
        
        output.push_str(&format!("{}\n\n", text));
    }
    
    output
}

/// Format transcription as CSV
pub fn format_as_csv(result: &TranscriptionResult) -> Result<String> {
    let mut output = String::new();
    
    // CSV header
    output.push_str("start_time,end_time,duration,text,confidence,speaker\n");
    
    for segment in &result.segments {
        let duration = segment.end_time - segment.start_time;
        let confidence = segment.confidence
            .map(|c| format!("{:.3}", c))
            .unwrap_or_else(|| "".to_string());
        let speaker = segment.speaker_id.as_deref().unwrap_or("");
        
        // Escape text for CSV
        let escaped_text = escape_csv_field(&segment.text);
        
        output.push_str(&format!("{:.3},{:.3},{:.3},{},{},{}\n",
            segment.start_time,
            segment.end_time,
            duration,
            escaped_text,
            confidence,
            speaker
        ));
    }
    
    Ok(output)
}

/// Format timestamp as MM:SS or HH:MM:SS
fn format_timestamp(seconds: f64) -> String {
    let total_seconds = seconds as u64;
    let hours = total_seconds / 3600;
    let minutes = (total_seconds % 3600) / 60;
    let secs = total_seconds % 60;
    
    if hours > 0 {
        format!("{:02}:{:02}:{:02}", hours, minutes, secs)
    } else {
        format!("{:02}:{:02}", minutes, secs)
    }
}

/// Format detailed timestamp with milliseconds as MM:SS.mmm or HH:MM:SS.mmm
fn format_detailed_timestamp(seconds: f64) -> String {
    let total_milliseconds = (seconds * 1000.0) as u64;
    let hours = total_milliseconds / 3_600_000;
    let minutes = (total_milliseconds % 3_600_000) / 60_000;
    let secs = (total_milliseconds % 60_000) / 1_000;
    let millis = total_milliseconds % 1_000;
    
    if hours > 0 {
        format!("{:02}:{:02}:{:02}.{:03}", hours, minutes, secs, millis)
    } else {
        format!("{:02}:{:02}.{:03}", minutes, secs, millis)
    }
}

/// Format timestamp for SRT format (HH:MM:SS,mmm)
fn format_srt_timestamp(seconds: f64) -> String {
    let total_milliseconds = (seconds * 1000.0) as u64;
    let hours = total_milliseconds / 3_600_000;
    let minutes = (total_milliseconds % 3_600_000) / 60_000;
    let secs = (total_milliseconds % 60_000) / 1_000;
    let millis = total_milliseconds % 1_000;
    
    format!("{:02}:{:02}:{:02},{:03}", hours, minutes, secs, millis)
}

/// Format timestamp for VTT format (HH:MM:SS.mmm)
fn format_vtt_timestamp(seconds: f64) -> String {
    let total_milliseconds = (seconds * 1000.0) as u64;
    let hours = total_milliseconds / 3_600_000;
    let minutes = (total_milliseconds % 3_600_000) / 60_000;
    let secs = (total_milliseconds % 60_000) / 1_000;
    let millis = total_milliseconds % 1_000;
    
    format!("{:02}:{:02}:{:02}.{:03}", hours, minutes, secs, millis)
}

/// Escape field for CSV format
fn escape_csv_field(field: &str) -> String {
    if field.contains('"') || field.contains(',') || field.contains('\n') {
        format!("\"{}\"", field.replace('"', "\"\""))
    } else {
        field.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::transcribe::{TranscriptSegment, TranscriptionMetadata};
    use crate::extractors::{AudioInfo, AudioFormat};
    
    fn create_test_result() -> TranscriptionResult {
        TranscriptionResult {
            transcript: "Hello world. This is a test.".to_string(),
            segments: vec![
                TranscriptSegment {
                    start_time: 0.0,
                    end_time: 2.5,
                    text: "Hello world.".to_string(),
                    confidence: Some(0.98),
                    speaker_id: Some("1".to_string()),
                },
                TranscriptSegment {
                    start_time: 2.5,
                    end_time: 5.0,
                    text: "This is a test.".to_string(),
                    confidence: Some(0.95),
                    speaker_id: Some("2".to_string()),
                },
            ],
            audio_info: AudioInfo {
                download_url: "https://example.com/audio.mp3".to_string(),
                duration: None,
                title: Some("Test Audio".to_string()),
                format: AudioFormat::Mp3,
                sample_rate: Some(44100),
                file_size: Some(1024),
                original_url: "https://example.com/video".to_string(),
            },
            audio_path: None,
            metadata: TranscriptionMetadata {
                job_id: "test-job".to_string(),
                language: "en-US".to_string(),
                processing_duration: Some(30.0),
                audio_duration: Some(5.0),
                confidence: Some(0.965),
                completed_at: chrono::Utc::now(),
            },
            words: None,
        }
    }
    
    #[test]
    fn test_format_as_text() {
        let result = create_test_result();
        let text = format_as_text(&result, false, false);
        
        assert!(text.contains("Hello world."));
        assert!(text.contains("This is a test."));
        assert!(text.contains("Speaker 1"));
        assert!(text.contains("Speaker 2"));
    }
    
    #[test]
    fn test_format_as_srt() {
        let result = create_test_result();
        let srt = format_as_srt(&result, false);
        
        assert!(srt.contains("1\n"));
        assert!(srt.contains("2\n"));
        assert!(srt.contains("00:00:00,000 --> 00:00:02,500"));
        assert!(srt.contains("00:00:02,500 --> 00:00:05,000"));
    }
    
    #[test]
    fn test_timestamp_formatting() {
        assert_eq!(format_timestamp(65.0), "01:05");
        assert_eq!(format_timestamp(3665.0), "01:01:05");
        assert_eq!(format_srt_timestamp(65.5), "00:01:05,500");
        assert_eq!(format_vtt_timestamp(65.5), "00:01:05.500");
    }
} 